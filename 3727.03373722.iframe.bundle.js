(self.webpackChunkpassbolt_styleguide=self.webpackChunkpassbolt_styleguide||[]).push([[3727],{"./node_modules/fetch-mock/dist/esm/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Ay:()=>esm});var glob_to_regexp=__webpack_require__("./node_modules/glob-to-regexp/index.js"),glob_to_regexp_default=__webpack_require__.n(glob_to_regexp);const valueTypes=new Set(["boolean","number","null","string","undefined"]),referenceTypes=new Set(["array","function","object","symbol"]),detectableTypes=new Set(["boolean","function","number","string","symbol"]),typeConstructors=new Set([Boolean,Number,String]);class TypeDescriptor{constructor(value){this.name=TypeDescriptor.of(value),this.isValueType=TypeDescriptor.isValueType(value),this.isReferenceType=TypeDescriptor.isReferenceType(value),this.isArray=TypeDescriptor.isArray(value),this.isBoolean=TypeDescriptor.isBoolean(value),this.isFunction=TypeDescriptor.isFunction(value),this.isNull=TypeDescriptor.isNull(value),this.isNumber=TypeDescriptor.isNumber(value),this.isObject=TypeDescriptor.isObject(value),this.isString=TypeDescriptor.isString(value),this.isSymbol=TypeDescriptor.isSymbol(value),this.isUndefined=TypeDescriptor.isUndefined(value)}static of(value){if(null===value)return"null";if(void 0===value)return"undefined";const detectedType=typeof value;if(detectableTypes.has(detectedType))return detectedType;if("object"===detectedType)return Array.isArray(value)?"array":typeConstructors.has(value.constructor)?value.constructor.name.toLowerCase():detectedType;throw new Error("Failed due to an unknown type.")}static from(value){return new TypeDescriptor(value)}static isValueType(value){return valueTypes.has(TypeDescriptor.of(value))}static isReferenceType(value){return referenceTypes.has(TypeDescriptor.of(value))}static isArray(value){return"array"===TypeDescriptor.of(value)}static isBoolean(value){return"boolean"===TypeDescriptor.of(value)}static isFunction(value){return"function"===TypeDescriptor.of(value)}static isNull(value){return"null"===TypeDescriptor.of(value)}static isNumber(value){return"number"===TypeDescriptor.of(value)}static isObject(value){return"object"===TypeDescriptor.of(value)}static isString(value){return"string"===TypeDescriptor.of(value)}static isSymbol(value){return"symbol"===TypeDescriptor.of(value)}static isUndefined(value){return"undefined"===TypeDescriptor.of(value)}}const allowedTypes=new Set(["array","object","function","null"]),isSubsetOf=function(subset,superset,visited=[]){const subsetType=TypeDescriptor.of(subset),supersetType=TypeDescriptor.of(superset);if(!allowedTypes.has(subsetType))throw new Error(`Type '${subsetType}' is not supported.`);if(!allowedTypes.has(supersetType))throw new Error(`Type '${supersetType}' is not supported.`);if(TypeDescriptor.isFunction(subset)){if(!TypeDescriptor.isFunction(superset))throw new Error(`Types '${subsetType}' and '${supersetType}' do not match.`);return subset.toString()===superset.toString()}if(TypeDescriptor.isArray(subset)){if(!TypeDescriptor.isArray(superset))throw new Error(`Types '${subsetType}' and '${supersetType}' do not match.`);if(subset.length>superset.length)return!1;for(const subsetItem of subset){let isItemInSuperset;switch(TypeDescriptor.of(subsetItem)){case"array":case"object":case"function":if(visited.includes(subsetItem))continue;visited.push(subsetItem),isItemInSuperset=superset.some(supersetItem=>{try{return isSubsetOf(subsetItem,supersetItem,visited)}catch{return!1}});break;default:isItemInSuperset=superset.includes(subsetItem)}if(!isItemInSuperset)return!1}return!0}if(TypeDescriptor.isObject(subset)){if(!TypeDescriptor.isObject(superset)||TypeDescriptor.isArray(superset))throw new Error(`Types '${subsetType}' and '${supersetType}' do not match.`);if(Object.keys(subset).length>Object.keys(superset).length)return!1;for(const[subsetKey,subsetValue]of Object.entries(subset)){const supersetValue=superset[subsetKey];switch(TypeDescriptor.of(subsetValue)){case"array":case"object":case"function":if(visited.includes(subsetValue))continue;visited.push(subsetValue);try{if(!isSubsetOf(subsetValue,supersetValue,visited))return!1}catch{return!1}break;default:if(subsetValue!==supersetValue)return!1}}return!0}if(TypeDescriptor.isNull(subset)){if(!TypeDescriptor.isNull(superset))throw new Error(`Types '${subsetType}' and '${supersetType}' do not match.`);return!0}throw new Error("Invalid operation.")};isSubsetOf.structural=function(subset,superset,visited=[]){if(!TypeDescriptor.isObject(subset))throw new Error(`Type '${TypeDescriptor.of(subset)}' is not supported.`);if(!TypeDescriptor.isObject(superset))throw new Error(`Type '${TypeDescriptor.of(superset)}' is not supported.`);for(const[subsetKey,subsetValue]of Object.entries(subset)){if(void 0===superset[subsetKey])return!1;const subsetValueType=TypeDescriptor.of(subsetValue),supersetValue=superset[subsetKey];if("object"===subsetValueType){if(visited.includes(subsetValue))continue;visited.push(subsetValue);try{if(!isSubsetOf.structural(subsetValue,supersetValue,visited))return!1}catch{return!1}}}return!0};var has=Object.prototype.hasOwnProperty;function find(iter,tar,key){for(key of iter.keys())if(dequal(key,tar))return key}function dequal(foo,bar){var ctor,len,tmp;if(foo===bar)return!0;if(foo&&bar&&(ctor=foo.constructor)===bar.constructor){if(ctor===Date)return foo.getTime()===bar.getTime();if(ctor===RegExp)return foo.toString()===bar.toString();if(ctor===Array){if((len=foo.length)===bar.length)for(;len--&&dequal(foo[len],bar[len]););return-1===len}if(ctor===Set){if(foo.size!==bar.size)return!1;for(len of foo){if((tmp=len)&&"object"==typeof tmp&&!(tmp=find(bar,tmp)))return!1;if(!bar.has(tmp))return!1}return!0}if(ctor===Map){if(foo.size!==bar.size)return!1;for(len of foo){if((tmp=len[0])&&"object"==typeof tmp&&!(tmp=find(bar,tmp)))return!1;if(!dequal(len[1],bar.get(tmp)))return!1}return!0}if(ctor===ArrayBuffer)foo=new Uint8Array(foo),bar=new Uint8Array(bar);else if(ctor===DataView){if((len=foo.byteLength)===bar.byteLength)for(;len--&&foo.getInt8(len)===bar.getInt8(len););return-1===len}if(ArrayBuffer.isView(foo)){if((len=foo.byteLength)===bar.byteLength)for(;len--&&foo[len]===bar[len];);return-1===len}if(!ctor||"object"==typeof foo){for(ctor in len=0,foo){if(has.call(foo,ctor)&&++len&&!has.call(bar,ctor))return!1;if(!(ctor in bar)||!dequal(foo[ctor],bar[ctor]))return!1}return Object.keys(bar).length===len}}return foo!=foo&&bar!=bar}const absoluteUrlRX=new RegExp("^[a-z]+://|^data:","i"),protocolRelativeUrlRX=new RegExp("^//","i");function normalizeUrl(url,allowRelativeUrls){if(url instanceof URL)return url.href;const primitiveUrl=String(url).valueOf();if(absoluteUrlRX.test(primitiveUrl))return new URL(primitiveUrl).href;if(protocolRelativeUrlRX.test(primitiveUrl))return new URL(primitiveUrl,"http://dummy").href.replace(/^[a-z]+:/,"");if("location"in globalThis)return primitiveUrl.startsWith("/")?`${globalThis.location.origin}${primitiveUrl}`:`${globalThis.location.href}/${primitiveUrl}`;if(allowRelativeUrls){const urlInstance=new URL(primitiveUrl,"http://dummy");return urlInstance.pathname+urlInstance.search}throw new Error("Relative urls are not support by default in node.js tests. Either use a utility such as jsdom to define globalThis.location or set `fetchMock.config.allowRelativeUrls = true`")}function createCallLogFromUrlAndOptions(url,options){const pendingPromises=[];if("string"==typeof url||url instanceof String||url instanceof URL){const normalizedUrl=normalizeUrl(url,!0),derivedOptions=options?{...options}:{};return derivedOptions.headers&&(derivedOptions.headers=normalizeHeaders(derivedOptions.headers)),derivedOptions.method=derivedOptions.method?derivedOptions.method.toLowerCase():"get",{args:[url,options],url:normalizedUrl,queryParams:new URLSearchParams(getQuery(normalizedUrl)),options:derivedOptions,signal:derivedOptions.signal,pendingPromises}}throw"object"==typeof url?new TypeError("fetch-mock: Unrecognised Request object. Read the Config and Installation sections of the docs"):new TypeError("fetch-mock: Invalid arguments passed to fetch")}function getPath(url){return(absoluteUrlRX.test(url)?new URL(url):new URL(url,"http://dummy")).pathname}function getQuery(url){const u=absoluteUrlRX.test(url)?new URL(url):new URL(url,"http://dummy");return u.search?u.search.substr(1):""}function normalizeHeaders(headers){let entries;return entries=headers instanceof Headers?[...headers.entries()]:Array.isArray(headers)?headers:Object.entries(headers),Object.fromEntries(entries.map(([key,val])=>[key.toLowerCase(),String(val).valueOf()]))}const isUrlMatcher=matcher=>matcher instanceof RegExp||"string"==typeof matcher||"object"==typeof matcher&&"href"in matcher,stringMatchers={begin:targetString=>({url})=>url.startsWith(targetString),end:targetString=>({url})=>url.endsWith(targetString),include:targetString=>({url})=>url.includes(targetString),glob:targetString=>{const urlRX=glob_to_regexp_default()(targetString);return({url})=>urlRX.test(url)},express:targetString=>{const urlRX=function parse(input,loose){if(input instanceof RegExp)return{keys:!1,pattern:input};var c,o,tmp,ext,keys=[],pattern="",arr=input.split("/");for(arr[0]||arr.shift();tmp=arr.shift();)"*"===(c=tmp[0])?(keys.push(c),pattern+="?"===tmp[1]?"(?:/(.*))?":"/(.*)"):":"===c?(o=tmp.indexOf("?",1),ext=tmp.indexOf(".",1),keys.push(tmp.substring(1,~o?o:~ext?ext:tmp.length)),pattern+=~o&&!~ext?"(?:/([^/]+?))?":"/([^/]+?)",~ext&&(pattern+=(~o?"?":"")+"\\"+tmp.substring(ext))):pattern+="/"+tmp;return{keys,pattern:new RegExp("^"+pattern+(loose?"(?=$|/)":"/?$"),"i")}}(targetString);return callLog=>{const vals=urlRX.pattern.exec(getPath(callLog.url));return vals?(vals.shift(),callLog.expressParams=urlRX.keys.reduce((map,paramName,i)=>vals[i]?Object.assign(map,{[paramName]:vals[i]}):map,{}),!0):(callLog.expressParams={},!1)}},path:targetString=>{const dotlessTargetString=getPath(targetString);return({url})=>{const path=getPath(url);return path===targetString||path===dotlessTargetString}}},formDataToObject=formData=>{const fields=[...formData],result={};return fields.forEach(([key,value])=>{result[key]=result[key]||[],result[key].push(value)}),result},getRegexpMatcher=regexp=>({url})=>regexp.test(url),getFullUrlMatcher=(route,matcherUrl,query)=>{const expectedUrl=normalizeUrl(matcherUrl,route.allowRelativeUrls);return route.url===matcherUrl&&(route.url=expectedUrl),({url})=>query&&expectedUrl.indexOf("?")?getPath(url)===getPath(expectedUrl):normalizeUrl(url,!0)===expectedUrl},builtInMatchers=[{name:"url",matcher:route=>{const{url:matcherUrl,query}=route;if("*"===matcherUrl)return()=>!0;if(matcherUrl instanceof RegExp)return getRegexpMatcher(matcherUrl);if(matcherUrl instanceof URL&&matcherUrl.href)return getFullUrlMatcher(route,matcherUrl.href,query);if("string"==typeof matcherUrl){for(const shorthand in stringMatchers)if(0===matcherUrl.indexOf(`${shorthand}:`)){const urlFragment=matcherUrl.replace(new RegExp(`^${shorthand}:`),"");return stringMatchers[shorthand](urlFragment)}return getFullUrlMatcher(route,matcherUrl,query)}if("object"==typeof matcherUrl){const matchers=Object.entries(matcherUrl).map(([key,pattern])=>{if("regexp"===key)return getRegexpMatcher(pattern);if(key in stringMatchers)return stringMatchers[key](pattern);throw new Error(`unrecognised url matching pattern: ${key}`)});return route=>matchers.every(matcher=>matcher(route))}}},{name:"query",matcher:({query:passedQuery})=>{if(!passedQuery)return;const expectedQuery=new URLSearchParams;for(const[key,value]of Object.entries(passedQuery))if(Array.isArray(value))for(const item of value)expectedQuery.append(key,"object"==typeof item||void 0===item?"":item.toString());else expectedQuery.append(key,"object"==typeof value||void 0===value?"":value.toString());const keys=Array.from(expectedQuery.keys());return({queryParams})=>keys.every(key=>{const expectedValues=expectedQuery.getAll(key).sort(),actualValues=queryParams.getAll(key).sort();return expectedValues.length===actualValues.length&&(Array.isArray(passedQuery[key])?expectedValues.every((expected,index)=>expected===actualValues[index]):dequal(actualValues,expectedValues))})}},{name:"method",matcher:({method:expectedMethod})=>{if(expectedMethod)return({options:{method}={}})=>{const actualMethod=method?method.toLowerCase():"get";return expectedMethod===actualMethod}}},{name:"headers",matcher:({headers:expectedHeaders})=>{if(!expectedHeaders)return;const expectation=normalizeHeaders(expectedHeaders);return({options:{headers={}}})=>{const lowerCaseHeaders=normalizeHeaders(headers);return Object.keys(expectation).every(headerName=>lowerCaseHeaders[headerName]===expectation[headerName])}}},{name:"missingHeaders",matcher:({missingHeaders:expectedMissingHeaders})=>{if(!expectedMissingHeaders)return;const expectation=expectedMissingHeaders.map(header=>header.toLowerCase());return({options:{headers={}}})=>{const lowerCaseHeaders=normalizeHeaders(headers);return expectation.every(headerName=>!(headerName in lowerCaseHeaders))}}},{name:"params",matcher:({params:expectedParams,url})=>{if(!expectedParams)return;if("string"!=typeof url||!/express:/.test(url))throw new Error("fetch-mock: matching on params is only possible when using an express: matcher");const expectedKeys=Object.keys(expectedParams);return({expressParams={}})=>expectedKeys.every(key=>expressParams[key]===expectedParams[key])}},{name:"body",matcher:route=>{let{body:expectedBody}=route,expectedBodyType="json";if(expectedBody)return expectedBody instanceof FormData&&(expectedBodyType="formData",expectedBody=formDataToObject(expectedBody)),({options:{body,method="get"}})=>{if(["get","head"].includes(method.toLowerCase()))return!1;let sentBody;try{if("string"==typeof body&&(sentBody=JSON.parse(body),"json"!==expectedBodyType))return!1}catch{}if(body instanceof FormData){if("formData"!==expectedBodyType)return!1;sentBody=formDataToObject(body)}return sentBody&&(route.matchPartialBody?isSubsetOf(expectedBody,sentBody):dequal(expectedBody,sentBody))}},usesBody:!0},{name:"matcherFunction",matcher:({matcherFunction})=>matcherFunction}],StatusTextMap={100:"Continue",101:"Switching Protocols",102:"Processing",200:"OK",201:"Created",202:"Accepted",203:"Non-Authoritative Information",204:"No Content",205:"Reset Content",206:"Partial Content",207:"Multi-Status",208:"Already Reported",226:"IM Used",300:"Multiple Choices",301:"Moved Permanently",302:"Found",303:"See Other",304:"Not Modified",305:"Use Proxy",307:"Temporary Redirect",308:"Permanent Redirect",400:"Bad Request",401:"Unauthorized",402:"Payment Required",403:"Forbidden",404:"Not Found",405:"Method Not Allowed",406:"Not Acceptable",407:"Proxy Authentication Required",408:"Request Timeout",409:"Conflict",410:"Gone",411:"Length Required",412:"Precondition Failed",413:"Payload Too Large",414:"URI Too Long",415:"Unsupported Media Type",416:"Range Not Satisfiable",417:"Expectation Failed",418:"I'm a teapot",421:"Misdirected Request",422:"Unprocessable Entity",423:"Locked",424:"Failed Dependency",425:"Unordered Collection",426:"Upgrade Required",428:"Precondition Required",429:"Too Many Requests",431:"Request Header Fields Too Large",451:"Unavailable For Legal Reasons",500:"Internal Server Error",501:"Not Implemented",502:"Bad Gateway",503:"Service Unavailable",504:"Gateway Timeout",505:"HTTP Version Not Supported",506:"Variant Also Negotiates",507:"Insufficient Storage",508:"Loop Detected",509:"Bandwidth Limit Exceeded",510:"Not Extended",511:"Network Authentication Required"};var _Route_instances,_a,_Route_responseSubscriptions,_Route_validate,_Route_sanitize,_Route_generateMatcher,_Route_limit,_Route_delayResponse,__classPrivateFieldSet=function(receiver,state,value,kind,f){if("m"===kind)throw new TypeError("Private method is not writable");if("a"===kind&&!f)throw new TypeError("Private accessor was defined without a setter");if("function"==typeof state?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot write private member to an object whose class did not declare it");return"a"===kind?f.call(receiver,value):f?f.value=value:state.set(receiver,value),value},__classPrivateFieldGet=function(receiver,state,kind,f){if("a"===kind&&!f)throw new TypeError("Private accessor was defined without a getter");if("function"==typeof state?receiver!==state||!f:!state.has(receiver))throw new TypeError("Cannot read private member from an object whose class did not declare it");return"m"===kind?f:"a"===kind?f.call(receiver):f?f.value:state.get(receiver)};class RouteConfigWrapper{constructor(config){Object.assign(this,config)}}class Route{constructor(config){_Route_instances.add(this),_Route_responseSubscriptions.set(this,void 0),this.init(config)}init(config){this.config=config,__classPrivateFieldSet(this,_Route_responseSubscriptions,[],"f"),__classPrivateFieldGet(this,_Route_instances,"m",_Route_sanitize).call(this),__classPrivateFieldGet(this,_Route_instances,"m",_Route_validate).call(this),__classPrivateFieldGet(this,_Route_instances,"m",_Route_generateMatcher).call(this),__classPrivateFieldGet(this,_Route_instances,"m",_Route_limit).call(this),__classPrivateFieldGet(this,_Route_instances,"m",_Route_delayResponse).call(this)}reset(){}waitFor(awaitedRoutes){const{response}=this.config;this.config.response=Promise.all(awaitedRoutes.map(awaitedRoute=>new Promise(res=>awaitedRoute.onRespond(()=>{res(void 0)})))).then(()=>response)}onRespond(func){__classPrivateFieldGet(this,_Route_responseSubscriptions,"f").push(func)}constructResponse(responseInput){const responseOptions=this.constructResponseOptions(responseInput),body=this.constructResponseBody(responseInput,responseOptions),responsePackage={response:new this.config.Response(body,responseOptions),responseOptions,responseInput};return __classPrivateFieldGet(this,_Route_responseSubscriptions,"f").forEach(func=>func()),responsePackage}constructResponseOptions(responseInput){const options=responseInput.options||{};return options.status=function sanitizeStatus(status){if(0===status)return 200;if(!status)return 200;if("number"==typeof status&&parseInt(String(status),10)!==status&&status>=200||status<600)return status;throw new TypeError(`fetch-mock: Invalid status ${status} passed on response object.\nTo respond with a JSON object that has status as a property assign the object to body\ne.g. {"body": {"status: "registered"}}`)}(responseInput.status),options.statusText=StatusTextMap[options.status],options.headers=new this.config.Headers(responseInput.headers),options}constructResponseBody(responseInput,responseOptions){let body=responseInput.body;const bodyIsBodyInit=function isBodyInit(body){return body instanceof Blob||body instanceof ArrayBuffer||ArrayBuffer.isView(body)||body instanceof DataView||body instanceof FormData||body instanceof ReadableStream||body instanceof URLSearchParams||body instanceof String||"string"==typeof body||null===body}(body);if(!bodyIsBodyInit)if(void 0===body)body=null;else{if("object"!=typeof body)throw new TypeError("Invalid body provided to construct response");body=JSON.stringify(body),responseOptions.headers.has("Content-Type")||responseOptions.headers.set("Content-Type","application/json")}if(this.config.includeContentLength&&!responseOptions.headers.has("Content-Length")&&!(body instanceof ReadableStream)&&!(body instanceof FormData)){let length=0;body instanceof Blob?length=body.size:body instanceof ArrayBuffer||ArrayBuffer.isView(body)||body instanceof DataView?length=body.byteLength:body instanceof URLSearchParams?length=body.toString().length:("string"==typeof body||body instanceof String)&&(length=body.length),responseOptions.headers.set("Content-Length",length.toString())}return body}static defineMatcher(matcher){_a.registeredMatchers.push(matcher)}}_a=Route,_Route_responseSubscriptions=new WeakMap,_Route_instances=new WeakSet,_Route_validate=function _Route_validate(){if(["matched","unmatched"].includes(this.config.name))throw new Error(`fetch-mock: Routes cannot use the reserved name \`${this.config.name}\``);if(!("response"in this.config))throw new Error("fetch-mock: Each route must define a response");if(!_a.registeredMatchers.some(({name})=>name in this.config))throw new Error("fetch-mock: Each route must specify some criteria for matching calls to fetch. To match all calls use '*'")},_Route_sanitize=function _Route_sanitize(){this.config.method&&(this.config.method=this.config.method.toLowerCase())},_Route_generateMatcher=function _Route_generateMatcher(){const activeMatchers=_a.registeredMatchers.filter(({name})=>name in this.config).map(({matcher,usesBody})=>({matcher:matcher(this.config),usesBody}));this.config.usesBody=activeMatchers.some(({usesBody})=>usesBody),this.matcher=normalizedRequest=>activeMatchers.every(({matcher})=>matcher(normalizedRequest))},_Route_limit=function _Route_limit(){if(!this.config.repeat)return;const originalMatcher=this.matcher;let timesLeft=this.config.repeat;this.matcher=callLog=>{if(timesLeft&&originalMatcher(callLog))return timesLeft--,!0},this.reset=()=>{timesLeft=this.config.repeat}},_Route_delayResponse=function _Route_delayResponse(){if(this.config.delay){const{response}=this.config;this.config.response=()=>new Promise(res=>setTimeout(()=>res(response),this.config.delay))}},Route.registeredMatchers=[],builtInMatchers.forEach(Route.defineMatcher);const esm_Route=Route,responseConfigProps=["body","headers","throws","status","redirectUrl"];function isPromise(response){return"function"==typeof response.then}function normalizeResponseInput(responseInput){return"number"==typeof responseInput?{status:responseInput}:"string"==typeof responseInput||function shouldSendAsObject(responseInput){if(responseConfigProps.some(prop=>prop in responseInput))return!Object.keys(responseInput).every(key=>responseConfigProps.includes(key));return!0}(responseInput)?{body:responseInput}:responseInput}function throwSpecExceptions({url,options:{headers,method,body}}){if(headers&&Object.entries(headers).forEach(([key])=>{if(/\s/.test(key))throw new TypeError("Invalid name")}),function hasCredentialsInUrl(url){const urlObject=new URL(url,absoluteUrlRX.test(url)?void 0:"http://dummy");return Boolean(urlObject.username||urlObject.password)}(url))throw new TypeError(`Request cannot be constructed from a URL that includes credentials: ${url}`);if(["get","head"].includes(method)&&body)throw new TypeError("Request with GET/HEAD method cannot have body.")}class Router{constructor(fetchMockConfig,{routes,fallbackRoute}={}){this.config=fetchMockConfig,this.routes=routes||[],this.fallbackRoute=fallbackRoute}needsToReadBody(request){return Boolean(request&&this.routes.some(route=>route.config.usesBody))}execute(callLog){return throwSpecExceptions(callLog),new Promise(async(resolve,reject)=>{const{url,options,request,pendingPromises}=callLog;if(callLog.signal){const abort=()=>{const error=new DOMException("The operation was aborted.","AbortError"),requestBody=request?.body||options?.body;requestBody instanceof ReadableStream&&(requestBody.locked?console.warn("fetch-mock: Locked request body can't be cancelled"):requestBody.cancel(error)),callLog?.response?.body&&(callLog.response.body.locked?console.warn("fetch-mock: Locked response body can't be cancelled"):callLog.response.body.cancel(error)),reject(error)};callLog.signal.aborted&&abort(),callLog.signal.addEventListener("abort",abort)}this.needsToReadBody(request)&&(options.body=await options.body);const route=(this.fallbackRoute?[...this.routes,this.fallbackRoute]:this.routes).find(route=>route.matcher(callLog));if(route)try{callLog.route=route;const{response,responseOptions,responseInput}=await this.generateResponse(callLog),observableResponse=this.createObservableResponse(response,responseOptions,responseInput,url,pendingPromises);callLog.response=response,resolve(observableResponse)}catch(err){reject(err)}else reject(new Error(`fetch-mock: No response or fallback rule to cover ${options&&options.method||"GET"} to ${url}`))})}async generateResponse(callLog){const responseInput=await(async callLog=>{let response=callLog.route.config.response;for(;;)if("function"==typeof response)response=response(callLog);else{if(!isPromise(response))return response;response=await response}})(callLog);if(responseInput instanceof Response)return{response:responseInput.clone(),responseOptions:{},responseInput:{}};const responseConfig=normalizeResponseInput(responseInput);if(responseConfig.throws)throw responseConfig.throws;return callLog.route.constructResponse(responseConfig)}createObservableResponse(response,responseConfig,responseInput,responseUrl,pendingPromises){return new Proxy(response,{get:(originalResponse,name)=>{if(responseInput.redirectUrl){if("url"===name)return responseInput.redirectUrl;if("redirected"===name)return!0}else{if("url"===name)return responseUrl;if("redirected"===name)return!1}if(0===responseInput.status){if("status"===name)return 0;if("statusText"===name)return""}return"function"==typeof response[name]?new Proxy(response[name],{apply:(func,thisArg,args)=>{const result=func.apply(response,args);return result.then&&pendingPromises.push(result.catch(()=>{})),result}}):originalResponse[name]}})}addRoute(matcher,response,nameOrOptions){const config={};matcher instanceof RouteConfigWrapper&&Object.assign(config,matcher),isUrlMatcher(matcher)?config.url=matcher:(matcher=>"function"==typeof matcher)(matcher)?config.matcherFunction=matcher:Object.assign(config,matcher),void 0!==response&&(config.response=response),nameOrOptions&&Object.assign(config,"string"==typeof nameOrOptions?function nameToOptions(options){return"string"==typeof options?{name:options}:options}(nameOrOptions):nameOrOptions);const route=new esm_Route({...this.config,...config});if(route.config.name&&this.routes.some(({config:{name:existingName}})=>route.config.name===existingName))throw new Error("fetch-mock: Adding route with same name as existing route.");if(route.config.waitFor){const routeNamesToWaitFor=Array.isArray(route.config.waitFor)?route.config.waitFor:[route.config.waitFor],routesToAwait=[];routeNamesToWaitFor.forEach(routeName=>{const routeToAwait=this.routes.find(({config:{name:existingName}})=>routeName===existingName);if(!routeToAwait)throw new Error(`Cannot wait for route \`${routeName}\`: route of that name does not exist`);routesToAwait.push(routeToAwait)}),route.waitFor(routesToAwait)}this.routes.push(route)}setFallback(response){this.fallbackRoute&&console.warn("calling fetchMock.catch() twice - are you sure you want to overwrite the previous fallback response"),this.fallbackRoute=new esm_Route({matcherFunction:()=>!0,response:response||"ok",...this.config}),this.fallbackRoute.config.isFallback=!0}removeRoutes({names,includeSticky,includeFallback}={}){includeFallback=includeFallback??!0,this.routes=this.routes.filter(({config:{sticky,name}})=>!(!sticky||includeSticky)||!!names&&!names.includes(name)),includeFallback&&delete this.fallbackRoute}modifyRoute(routeName,options){const route=this.routes.find(({config:{name}})=>name===routeName);if(!route)throw new Error(`Cannot call modifyRoute() on route \`${routeName}\`: route of that name not found`);if(route.config.sticky)throw new Error(`Cannot call modifyRoute() on route \`${routeName}\`: route is sticky and cannot be modified`);if("name"in options)throw new Error(`Cannot rename the route \`${routeName}\` as \`${options.name}\`: renaming routes is not supported`);if("sticky"in options)throw new Error(`Altering the stickiness of route \`${routeName}\` is not supported`);const newConfig={...route.config,...options};Object.entries(options).forEach(([key,value])=>{null===value&&delete newConfig[key]}),route.init(newConfig)}}const esm_CallHistory=class CallHistory{constructor(config,router){this.callLogs=[],this.config=config,this.router=router}recordCall(callLog){this.callLogs.push(callLog)}clear(){this.callLogs.forEach(({route})=>{route&&route.reset()}),this.callLogs=[]}async flush(waitForResponseMethods){const queuedPromises=this.callLogs.flatMap(call=>call.pendingPromises);await Promise.allSettled(queuedPromises),waitForResponseMethods&&(await Promise.resolve(),await this.flush())}calls(filter,options){let calls=[...this.callLogs];if(void 0===filter&&!options)return calls;if((filter=>"boolean"==typeof filter||["matched","unmatched"].includes(filter))(filter)){if([!0,"matched"].includes(filter)?calls=calls.filter(({route})=>!route?.config||!route.config.isFallback):[!1,"unmatched"].includes(filter)&&(calls=calls.filter(({route})=>Boolean(route?.config&&route.config.isFallback))),!options)return calls}else if((filter=>"string"==typeof filter&&/^[\da-zA-Z-]+$/.test(filter)&&!["matched","unmatched"].includes(filter))(filter)){if(calls=calls.filter(({route})=>route?.config?.name===filter),!options)return calls}else options=isUrlMatcher(filter)?{url:filter,...options||{}}:{...filter,...options||{}};const{matcher}=new esm_Route({response:"ok",...options});return calls=calls.filter(({url,options})=>matcher(createCallLogFromUrlAndOptions(url,options))),calls}called(filter,options){return Boolean(this.calls(filter,options).length)}lastCall(filter,options){return this.calls(filter,options).pop()}done(routeNames){let routesToCheck=this.router.routes;return routeNames&&(routeNames=Array.isArray(routeNames)?routeNames:[routeNames],routesToCheck=this.router.routes.filter(({config:{name}})=>routeNames.includes(name))),routesToCheck.map(route=>{const calls=this.callLogs.filter(({route:routeApplied})=>routeApplied===route);if(!calls.length)return console.warn(`Warning: ${route.config.name} not called`),!1;const expectedTimes=route.config.repeat;if(!expectedTimes)return!0;const actualTimes=calls.length;return!(expectedTimes>actualTimes)||(console.warn(`Warning: ${route.config.name} only called ${actualTimes} times, but ${expectedTimes} expected`),!1)}).every(isDone=>isDone)}},defaultFetchMockConfig={includeContentLength:!0,matchPartialBody:!1,Request:globalThis.Request,Response:globalThis.Response,Headers:globalThis.Headers,fetch:globalThis.fetch},defineShorthand=shorthandOptions=>function shorthand(matcher,response,options){return this.route(matcher,response,Object.assign(options||{},shorthandOptions))},defineGreedyShorthand=shorthandOptions=>function(response,options){return this.route("*",response,Object.assign(options||{},shorthandOptions))};class FetchMock{constructor(config,router){this.sticky=defineShorthand({sticky:!0}),this.once=defineShorthand({repeat:1}),this.any=defineGreedyShorthand({}),this.anyOnce=defineGreedyShorthand({repeat:1}),this.get=defineShorthand({method:"get"}),this.getOnce=defineShorthand({method:"get",repeat:1}),this.post=defineShorthand({method:"post"}),this.postOnce=defineShorthand({method:"post",repeat:1}),this.put=defineShorthand({method:"put"}),this.putOnce=defineShorthand({method:"put",repeat:1}),this.delete=defineShorthand({method:"delete"}),this.deleteOnce=defineShorthand({method:"delete",repeat:1}),this.head=defineShorthand({method:"head"}),this.headOnce=defineShorthand({method:"head",repeat:1}),this.patch=defineShorthand({method:"patch"}),this.patchOnce=defineShorthand({method:"patch",repeat:1}),this.config=config,this.router=new Router(this.config,{routes:router?[...router.routes]:[],fallbackRoute:router?router.fallbackRoute:null}),this.callHistory=new esm_CallHistory(this.config,this.router),this.fetchHandler=this.fetchHandler.bind(this),Object.assign(this.fetchHandler,{fetchMock:this})}createInstance(){return new FetchMock({...this.config},this.router)}async fetchHandler(requestInput,requestInit){let callLog;callLog=requestInput instanceof this.config.Request?await async function createCallLogFromRequest(request,options){const derivedOptions={method:request.method};try{try{derivedOptions.body=await request.clone().formData()}catch{derivedOptions.body=await request.clone().text()}}catch{}request.headers&&(derivedOptions.headers=normalizeHeaders(request.headers));const url=normalizeUrl(request.url,!0);return{args:[request,options],url,queryParams:new URLSearchParams(getQuery(url)),options:Object.assign(derivedOptions,options||{}),request,signal:options&&options.signal||request.signal,pendingPromises:[]}}(requestInput,requestInit):createCallLogFromUrlAndOptions(requestInput,requestInit),this.callHistory.recordCall(callLog);const responsePromise=this.router.execute(callLog);return callLog.pendingPromises.push(responsePromise),responsePromise}route(matcher,response,options){return this.router.addRoute(matcher,response,options),this}catch(response){return this.router.setFallback(response),this}defineMatcher(matcher){esm_Route.defineMatcher(matcher)}removeRoutes(options){return this.router.removeRoutes(options),this}removeRoute(routeName){return this.router.removeRoutes({names:[routeName]}),this}modifyRoute(routeName,options){return this.router.modifyRoute(routeName,options),this}clearHistory(){return this.callHistory.clear(),this}mockGlobal(){return globalThis.fetch=this.fetchHandler,this}unmockGlobal(){return globalThis.fetch=this.config.fetch,this}hardReset(options){return this.clearHistory(),this.removeRoutes(options),this.unmockGlobal(),this}spy(matcher,name){const boundFetch=this.config.fetch.bind(globalThis);return matcher?this.route(matcher,({args})=>boundFetch(...args),name):this.catch(({args})=>boundFetch(...args)),this}spyGlobal(){return this.mockGlobal(),this.spy()}}const esm=new FetchMock({...defaultFetchMockConfig})},"./node_modules/glob-to-regexp/index.js":module=>{module.exports=function(glob,opts){if("string"!=typeof glob)throw new TypeError("Expected a string");for(var c,str=String(glob),reStr="",extended=!!opts&&!!opts.extended,globstar=!!opts&&!!opts.globstar,inGroup=!1,flags=opts&&"string"==typeof opts.flags?opts.flags:"",i=0,len=str.length;i<len;i++)switch(c=str[i]){case"/":case"$":case"^":case"+":case".":case"(":case")":case"=":case"!":case"|":reStr+="\\"+c;break;case"?":if(extended){reStr+=".";break}case"[":case"]":if(extended){reStr+=c;break}case"{":if(extended){inGroup=!0,reStr+="(";break}case"}":if(extended){inGroup=!1,reStr+=")";break}case",":if(inGroup){reStr+="|";break}reStr+="\\"+c;break;case"*":for(var prevChar=str[i-1],starCount=1;"*"===str[i+1];)starCount++,i++;var nextChar=str[i+1];if(globstar)starCount>1&&("/"===prevChar||void 0===prevChar)&&("/"===nextChar||void 0===nextChar)?(reStr+="((?:[^/]*(?:/|$))*)",i++):reStr+="([^/]*)";else reStr+=".*";break;default:reStr+=c}return flags&&~flags.indexOf("g")||(reStr="^"+reStr+"$"),new RegExp(reStr,flags)}},"./node_modules/uuid/dist/esm-browser/stringify.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>__WEBPACK_DEFAULT_EXPORT__});for(var _validate_js__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/uuid/dist/esm-browser/validate.js"),byteToHex=[],i=0;i<256;++i)byteToHex.push((i+256).toString(16).substr(1));const __WEBPACK_DEFAULT_EXPORT__=function stringify(arr){var offset=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,uuid=(byteToHex[arr[offset+0]]+byteToHex[arr[offset+1]]+byteToHex[arr[offset+2]]+byteToHex[arr[offset+3]]+"-"+byteToHex[arr[offset+4]]+byteToHex[arr[offset+5]]+"-"+byteToHex[arr[offset+6]]+byteToHex[arr[offset+7]]+"-"+byteToHex[arr[offset+8]]+byteToHex[arr[offset+9]]+"-"+byteToHex[arr[offset+10]]+byteToHex[arr[offset+11]]+byteToHex[arr[offset+12]]+byteToHex[arr[offset+13]]+byteToHex[arr[offset+14]]+byteToHex[arr[offset+15]]).toLowerCase();if(!(0,_validate_js__WEBPACK_IMPORTED_MODULE_0__.A)(uuid))throw TypeError("Stringified UUID is invalid");return uuid}},"./node_modules/uuid/dist/esm-browser/v4.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";var getRandomValues;__webpack_require__.d(__webpack_exports__,{A:()=>esm_browser_v4});var rnds8=new Uint8Array(16);function rng(){if(!getRandomValues&&!(getRandomValues="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto)))throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");return getRandomValues(rnds8)}var stringify=__webpack_require__("./node_modules/uuid/dist/esm-browser/stringify.js");const esm_browser_v4=function v4(options,buf,offset){var rnds=(options=options||{}).random||(options.rng||rng)();if(rnds[6]=15&rnds[6]|64,rnds[8]=63&rnds[8]|128,buf){offset=offset||0;for(var i=0;i<16;++i)buf[offset+i]=rnds[i];return buf}return(0,stringify.A)(rnds)}},"./node_modules/uuid/dist/esm-browser/validate.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{A:()=>esm_browser_validate});const regex=/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;const esm_browser_validate=function validate(uuid){return"string"==typeof uuid&&regex.test(uuid)}},"./node_modules/validator/es/lib/util/assertString.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function assertString(input){if(null==input)throw new TypeError("Expected a string but received a ".concat(input));if("String"!==input.constructor.name)throw new TypeError("Expected a string but received a ".concat(input.constructor.name))}__webpack_require__.d(__webpack_exports__,{A:()=>assertString})}}]);