/*! For license information please see 2263.5afd8fe2.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkpassbolt_styleguide=self.webpackChunkpassbolt_styleguide||[]).push([[2263],{"./node_modules/otpauth/dist/otpauth.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{_k:()=>TOTP});function anumber(n){if(!Number.isSafeInteger(n)||n<0)throw new Error("positive integer expected, got "+n)}function abytes(b,...lengths){if(!function isBytes(a){return a instanceof Uint8Array||ArrayBuffer.isView(a)&&"Uint8Array"===a.constructor.name}(b))throw new Error("Uint8Array expected");if(lengths.length>0&&!lengths.includes(b.length))throw new Error("Uint8Array expected of length "+lengths+", got length="+b.length)}function aexists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function aoutput(out,instance){abytes(out);const min=instance.outputLen;if(out.length<min)throw new Error("digestInto() expects output buffer of length at least "+min)}function clean(...arrays){for(let i=0;i<arrays.length;i++)arrays[i].fill(0)}function createView(arr){return new DataView(arr.buffer,arr.byteOffset,arr.byteLength)}function rotr(word,shift){return word<<32-shift|word>>>shift}function rotl(word,shift){return word<<shift|word>>>32-shift>>>0}function byteSwap(word){return word<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255}const swap32IfBE=(()=>68===new Uint8Array(new Uint32Array([287454020]).buffer)[0])()?u=>u:function byteSwap32(arr){for(let i=0;i<arr.length;i++)arr[i]=byteSwap(arr[i]);return arr};function toBytes(data){return"string"==typeof data&&(data=function utf8ToBytes(str){if("string"!=typeof str)throw new Error("string expected");return new Uint8Array((new TextEncoder).encode(str))}(data)),abytes(data),data}class Hash{}function createHasher(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC}class HMAC extends Hash{update(buf){return aexists(this),this.iHash.update(buf),this}digestInto(out){aexists(this),abytes(out,this.outputLen),this.finished=!0,this.iHash.digestInto(out),this.oHash.update(out),this.oHash.digestInto(out),this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);return this.digestInto(out),out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;return to.finished=finished,to.destroyed=destroyed,to.blockLen=blockLen,to.outputLen=outputLen,to.oHash=oHash._cloneInto(to.oHash),to.iHash=iHash._cloneInto(to.iHash),to}clone(){return this._cloneInto()}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}constructor(hash,_key){super(),this.finished=!1,this.destroyed=!1,function ahash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.createHasher");anumber(h.outputLen),anumber(h.blockLen)}(hash);const key=toBytes(_key);if(this.iHash=hash.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen,pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad),this.oHash=hash.create();for(let i=0;i<pad.length;i++)pad[i]^=106;this.oHash.update(pad),clean(pad)}}const hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest();function Chi(a,b,c){return a&b^~a&c}function Maj(a,b,c){return a&b^a&c^b&c}hmac.create=(hash,key)=>new HMAC(hash,key);class HashMD extends Hash{update(data){aexists(this),abytes(data=toBytes(data));const{view,buffer,blockLen}=this,len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take===blockLen){const dataView=createView(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos);continue}buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0)}return this.length+=data.length,this.roundClean(),this}digestInto(out){aexists(this),aoutput(out,this),this.finished=!0;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128,clean(this.buffer.subarray(pos)),this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(let i=pos;i<blockLen;i++)buffer[i]=0;!function setBigUint64(view,byteOffset,value,isLE){if("function"==typeof view.setBigUint64)return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32),_u32_max=BigInt(4294967295),wh=Number(value>>_32n&_u32_max),wl=Number(value&_u32_max),h=isLE?4:0,l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE),view.setUint32(byteOffset+l,wl,isLE)}(view,blockLen-8,BigInt(8*this.length),isLE),this.process(view,0);const oview=createView(out),len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4,state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);return this.destroy(),res}_cloneInto(to){to||(to=new this.constructor),to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;return to.destroyed=destroyed,to.finished=finished,to.length=length,to.pos=pos,length%blockLen&&to.buffer.set(buffer),to}clone(){return this._cloneInto()}constructor(blockLen,outputLen,padOffset,isLE){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=blockLen,this.outputLen=outputLen,this.padOffset=padOffset,this.isLE=isLE,this.buffer=new Uint8Array(blockLen),this.view=createView(this.buffer)}}const SHA256_IV=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA224_IV=Uint32Array.from([3238371032,914150663,812702999,4144912697,4290775857,1750603025,1694076839,3204075428]),SHA384_IV=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),SHA512_IV=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),SHA1_IV=Uint32Array.from([1732584193,4023233417,2562383102,271733878,3285377520]),SHA1_W=new Uint32Array(80);class SHA1 extends HashMD{get(){const{A,B,C,D,E}=this;return[A,B,C,D,E]}set(A,B,C,D,E){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA1_W[i]=view.getUint32(offset,!1);for(let i=16;i<80;i++)SHA1_W[i]=rotl(SHA1_W[i-3]^SHA1_W[i-8]^SHA1_W[i-14]^SHA1_W[i-16],1);let{A,B,C,D,E}=this;for(let i=0;i<80;i++){let F,K;i<20?(F=Chi(B,C,D),K=1518500249):i<40?(F=B^C^D,K=1859775393):i<60?(F=Maj(B,C,D),K=2400959708):(F=B^C^D,K=3395469782);const T=rotl(A,5)+F+E+K+SHA1_W[i]|0;E=D,D=C,C=rotl(B,30),B=A,A=T}A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,this.set(A,B,C,D,E)}roundClean(){clean(SHA1_W)}destroy(){this.set(0,0,0,0,0),clean(this.buffer)}constructor(){super(64,20,8,!1),this.A=0|SHA1_IV[0],this.B=0|SHA1_IV[1],this.C=0|SHA1_IV[2],this.D=0|SHA1_IV[3],this.E=0|SHA1_IV[4]}}const sha1=createHasher(()=>new SHA1),U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,le=!1){return le?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:0|Number(n>>_32n&U32_MASK64),l:0|Number(n&U32_MASK64)}}function split(lst,le=!1){const len=lst.length;let Ah=new Uint32Array(len),Al=new Uint32Array(len);for(let i=0;i<len;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const shrSH=(h,_l,s)=>h>>>s,shrSL=(h,l,s)=>h<<32-s|l>>>s,rotrSH=(h,l,s)=>h>>>s|l<<32-s,rotrSL=(h,l,s)=>h<<32-s|l>>>s,rotrBH=(h,l,s)=>h<<64-s|l>>>s-32,rotrBL=(h,l,s)=>h>>>s-32|l<<64-s;function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:0|l}}const add3L=(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0),add3H=(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0,add4L=(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0),add4H=(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0,add5L=(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0),add5H=(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0,SHA256_K=Uint32Array.from([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_W=new Uint32Array(64);class SHA256 extends HashMD{get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E,this.F=0|F,this.G=0|G,this.H=0|H}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,!1);for(let i=16;i<64;i++){const W15=SHA256_W[i-15],W2=SHA256_W[i-2],s0=rotr(W15,7)^rotr(W15,18)^W15>>>3,s1=rotr(W2,17)^rotr(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const T1=H+(rotr(E,6)^rotr(E,11)^rotr(E,25))+Chi(E,F,G)+SHA256_K[i]+SHA256_W[i]|0,T2=(rotr(A,2)^rotr(A,13)^rotr(A,22))+Maj(A,B,C)|0;H=G,G=F,F=E,E=D+T1|0,D=C,C=B,B=A,A=T1+T2|0}A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,F=F+this.F|0,G=G+this.G|0,H=H+this.H|0,this.set(A,B,C,D,E,F,G,H)}roundClean(){clean(SHA256_W)}destroy(){this.set(0,0,0,0,0,0,0,0),clean(this.buffer)}constructor(outputLen=32){super(64,outputLen,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}}class SHA224 extends SHA256{constructor(){super(28),this.A=0|SHA224_IV[0],this.B=0|SHA224_IV[1],this.C=0|SHA224_IV[2],this.D=0|SHA224_IV[3],this.E=0|SHA224_IV[4],this.F=0|SHA224_IV[5],this.G=0|SHA224_IV[6],this.H=0|SHA224_IV[7]}}const K512=(()=>split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map(n=>BigInt(n))))(),SHA512_Kh=(()=>K512[0])(),SHA512_Kl=(()=>K512[1])(),SHA512_W_H=new Uint32Array(80),SHA512_W_L=new Uint32Array(80);class SHA512 extends HashMD{get(){const{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;return[Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl]}set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl){this.Ah=0|Ah,this.Al=0|Al,this.Bh=0|Bh,this.Bl=0|Bl,this.Ch=0|Ch,this.Cl=0|Cl,this.Dh=0|Dh,this.Dl=0|Dl,this.Eh=0|Eh,this.El=0|El,this.Fh=0|Fh,this.Fl=0|Fl,this.Gh=0|Gh,this.Gl=0|Gl,this.Hh=0|Hh,this.Hl=0|Hl}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA512_W_H[i]=view.getUint32(offset),SHA512_W_L[i]=view.getUint32(offset+=4);for(let i=16;i<80;i++){const W15h=0|SHA512_W_H[i-15],W15l=0|SHA512_W_L[i-15],s0h=rotrSH(W15h,W15l,1)^rotrSH(W15h,W15l,8)^shrSH(W15h,0,7),s0l=rotrSL(W15h,W15l,1)^rotrSL(W15h,W15l,8)^shrSL(W15h,W15l,7),W2h=0|SHA512_W_H[i-2],W2l=0|SHA512_W_L[i-2],s1h=rotrSH(W2h,W2l,19)^rotrBH(W2h,W2l,61)^shrSH(W2h,0,6),s1l=rotrSL(W2h,W2l,19)^rotrBL(W2h,W2l,61)^shrSL(W2h,W2l,6),SUMl=add4L(s0l,s1l,SHA512_W_L[i-7],SHA512_W_L[i-16]),SUMh=add4H(SUMl,s0h,s1h,SHA512_W_H[i-7],SHA512_W_H[i-16]);SHA512_W_H[i]=0|SUMh,SHA512_W_L[i]=0|SUMl}let{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;for(let i=0;i<80;i++){const sigma1h=rotrSH(Eh,El,14)^rotrSH(Eh,El,18)^rotrBH(Eh,El,41),sigma1l=rotrSL(Eh,El,14)^rotrSL(Eh,El,18)^rotrBL(Eh,El,41),CHIh=Eh&Fh^~Eh&Gh,T1ll=add5L(Hl,sigma1l,El&Fl^~El&Gl,SHA512_Kl[i],SHA512_W_L[i]),T1h=add5H(T1ll,Hh,sigma1h,CHIh,SHA512_Kh[i],SHA512_W_H[i]),T1l=0|T1ll,sigma0h=rotrSH(Ah,Al,28)^rotrBH(Ah,Al,34)^rotrBH(Ah,Al,39),sigma0l=rotrSL(Ah,Al,28)^rotrBL(Ah,Al,34)^rotrBL(Ah,Al,39),MAJh=Ah&Bh^Ah&Ch^Bh&Ch,MAJl=Al&Bl^Al&Cl^Bl&Cl;Hh=0|Gh,Hl=0|Gl,Gh=0|Fh,Gl=0|Fl,Fh=0|Eh,Fl=0|El,({h:Eh,l:El}=add(0|Dh,0|Dl,0|T1h,0|T1l)),Dh=0|Ch,Dl=0|Cl,Ch=0|Bh,Cl=0|Bl,Bh=0|Ah,Bl=0|Al;const All=add3L(T1l,sigma0l,MAJl);Ah=add3H(All,T1h,sigma0h,MAJh),Al=0|All}({h:Ah,l:Al}=add(0|this.Ah,0|this.Al,0|Ah,0|Al)),({h:Bh,l:Bl}=add(0|this.Bh,0|this.Bl,0|Bh,0|Bl)),({h:Ch,l:Cl}=add(0|this.Ch,0|this.Cl,0|Ch,0|Cl)),({h:Dh,l:Dl}=add(0|this.Dh,0|this.Dl,0|Dh,0|Dl)),({h:Eh,l:El}=add(0|this.Eh,0|this.El,0|Eh,0|El)),({h:Fh,l:Fl}=add(0|this.Fh,0|this.Fl,0|Fh,0|Fl)),({h:Gh,l:Gl}=add(0|this.Gh,0|this.Gl,0|Gh,0|Gl)),({h:Hh,l:Hl}=add(0|this.Hh,0|this.Hl,0|Hh,0|Hl)),this.set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl)}roundClean(){clean(SHA512_W_H,SHA512_W_L)}destroy(){clean(this.buffer),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}constructor(outputLen=64){super(128,outputLen,16,!1),this.Ah=0|SHA512_IV[0],this.Al=0|SHA512_IV[1],this.Bh=0|SHA512_IV[2],this.Bl=0|SHA512_IV[3],this.Ch=0|SHA512_IV[4],this.Cl=0|SHA512_IV[5],this.Dh=0|SHA512_IV[6],this.Dl=0|SHA512_IV[7],this.Eh=0|SHA512_IV[8],this.El=0|SHA512_IV[9],this.Fh=0|SHA512_IV[10],this.Fl=0|SHA512_IV[11],this.Gh=0|SHA512_IV[12],this.Gl=0|SHA512_IV[13],this.Hh=0|SHA512_IV[14],this.Hl=0|SHA512_IV[15]}}class SHA384 extends SHA512{constructor(){super(48),this.Ah=0|SHA384_IV[0],this.Al=0|SHA384_IV[1],this.Bh=0|SHA384_IV[2],this.Bl=0|SHA384_IV[3],this.Ch=0|SHA384_IV[4],this.Cl=0|SHA384_IV[5],this.Dh=0|SHA384_IV[6],this.Dl=0|SHA384_IV[7],this.Eh=0|SHA384_IV[8],this.El=0|SHA384_IV[9],this.Fh=0|SHA384_IV[10],this.Fl=0|SHA384_IV[11],this.Gh=0|SHA384_IV[12],this.Gl=0|SHA384_IV[13],this.Hh=0|SHA384_IV[14],this.Hl=0|SHA384_IV[15]}}const sha256=createHasher(()=>new SHA256),sha224=createHasher(()=>new SHA224),sha512=createHasher(()=>new SHA512),sha384=createHasher(()=>new SHA384),_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113),SHA3_PI=[],SHA3_ROTL=[],_SHA3_IOTA=[];for(let round=0,R=_1n,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5],SHA3_PI.push(2*(5*y+x)),SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n;for(let j=0;j<7;j++)R=(R<<_1n^(R>>_7n)*_0x71n)%_256n,R&_2n&&(t^=_1n<<(_1n<<BigInt(j))-_1n);_SHA3_IOTA.push(t)}const IOTAS=split(_SHA3_IOTA,!0),SHA3_IOTA_H=IOTAS[0],SHA3_IOTA_L=IOTAS[1],rotlH=(h,l,s)=>s>32?((h,l,s)=>l<<s-32|h>>>64-s)(h,l,s):((h,l,s)=>h<<s|l>>>32-s)(h,l,s),rotlL=(h,l,s)=>s>32?((h,l,s)=>h<<s-32|l>>>64-s)(h,l,s):((h,l,s)=>l<<s|h>>>32-s)(h,l,s);class Keccak extends Hash{clone(){return this._cloneInto()}keccak(){swap32IfBE(this.state32),function keccakP(s,rounds=24){const B=new Uint32Array(10);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10,idx0=(x+2)%10,B0=B[idx0],B1=B[idx0+1],Th=rotlH(B0,B1,1)^B[idx1],Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10)s[x+y]^=Th,s[x+y+1]^=Tl}let curH=s[2],curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t],Th=rotlH(curH,curL,shift),Tl=rotlL(curH,curL,shift),PI=SHA3_PI[t];curH=s[PI],curL=s[PI+1],s[PI]=Th,s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round],s[1]^=SHA3_IOTA_L[round]}clean(B)}(this.state32,this.rounds),swap32IfBE(this.state32),this.posOut=0,this.pos=0}update(data){aexists(this),abytes(data=toBytes(data));const{blockLen,state}=this,len=data.length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];this.pos===blockLen&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix,128&suffix&&pos===blockLen-1&&this.keccak(),state[blockLen-1]^=128,this.keccak()}writeInto(out){aexists(this,!1),abytes(out),this.finish();const bufferOut=this.state,{blockLen}=this;for(let pos=0,len=out.length;pos<len;){this.posOut>=blockLen&&this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos),this.posOut+=take,pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){return anumber(bytes),this.xofInto(new Uint8Array(bytes))}digestInto(out){if(aoutput(out,this),this.finished)throw new Error("digest() was already called");return this.writeInto(out),this.destroy(),out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,clean(this.state)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;return to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),to.state32.set(this.state32),to.pos=this.pos,to.posOut=this.posOut,to.finished=this.finished,to.rounds=rounds,to.suffix=suffix,to.outputLen=outputLen,to.enableXOF=enableXOF,to.destroyed=this.destroyed,to}constructor(blockLen,suffix,outputLen,enableXOF=!1,rounds=24){if(super(),this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,this.enableXOF=!1,this.blockLen=blockLen,this.suffix=suffix,this.outputLen=outputLen,this.enableXOF=enableXOF,this.rounds=rounds,anumber(outputLen),!(0<blockLen&&blockLen<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=function u32(arr){return new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4))}(this.state)}}const gen=(suffix,blockLen,outputLen)=>createHasher(()=>new Keccak(blockLen,suffix,outputLen)),sha3_224=(()=>gen(6,144,28))(),sha3_256=(()=>gen(6,136,32))(),sha3_384=(()=>gen(6,104,48))(),sha3_512=(()=>gen(6,72,64))(),globalScope=(()=>{if("object"==typeof globalThis)return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if("undefined"!=typeof __GLOBALTHIS__)return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}return"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==__webpack_require__.g?__webpack_require__.g:void 0})(),nobleHashes={SHA1:sha1,SHA224:sha224,SHA256:sha256,SHA384:sha384,SHA512:sha512,"SHA3-224":sha3_224,"SHA3-256":sha3_256,"SHA3-384":sha3_384,"SHA3-512":sha3_512},canonicalizeAlgorithm=algorithm=>{switch(!0){case/^(?:SHA-?1|SSL3-SHA1)$/i.test(algorithm):return"SHA1";case/^SHA(?:2?-)?224$/i.test(algorithm):return"SHA224";case/^SHA(?:2?-)?256$/i.test(algorithm):return"SHA256";case/^SHA(?:2?-)?384$/i.test(algorithm):return"SHA384";case/^SHA(?:2?-)?512$/i.test(algorithm):return"SHA512";case/^SHA3-224$/i.test(algorithm):return"SHA3-224";case/^SHA3-256$/i.test(algorithm):return"SHA3-256";case/^SHA3-384$/i.test(algorithm):return"SHA3-384";case/^SHA3-512$/i.test(algorithm):return"SHA3-512";default:throw new TypeError(`Unknown hash algorithm: ${algorithm}`)}},ALPHABET="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",base32Decode=str=>{let end=(str=str.replace(/ /g,"")).length;for(;"="===str[end-1];)--end;str=(end<str.length?str.substring(0,end):str).toUpperCase();const buf=new ArrayBuffer(5*str.length/8|0),arr=new Uint8Array(buf);let bits=0,value=0,index=0;for(let i=0;i<str.length;i++){const idx=ALPHABET.indexOf(str[i]);if(-1===idx)throw new TypeError(`Invalid character found: ${str[i]}`);value=value<<5|idx,bits+=5,bits>=8&&(bits-=8,arr[index++]=value>>>bits)}return arr},base32Encode=arr=>{let bits=0,value=0,str="";for(let i=0;i<arr.length;i++)for(value=value<<8|arr[i],bits+=8;bits>=5;)str+=ALPHABET[value>>>bits-5&31],bits-=5;return bits>0&&(str+=ALPHABET[value<<5-bits&31]),str},hexDecode=str=>{str=str.replace(/ /g,"");const buf=new ArrayBuffer(str.length/2),arr=new Uint8Array(buf);for(let i=0;i<str.length;i+=2)arr[i/2]=parseInt(str.substring(i,i+2),16);return arr},hexEncode=arr=>{let str="";for(let i=0;i<arr.length;i++){const hex=arr[i].toString(16);1===hex.length&&(str+="0"),str+=hex}return str.toUpperCase()},latin1Decode=str=>{const buf=new ArrayBuffer(str.length),arr=new Uint8Array(buf);for(let i=0;i<str.length;i++)arr[i]=255&str.charCodeAt(i);return arr},latin1Encode=arr=>{let str="";for(let i=0;i<arr.length;i++)str+=String.fromCharCode(arr[i]);return str},ENCODER=globalScope.TextEncoder?new globalScope.TextEncoder:null,DECODER=globalScope.TextDecoder?new globalScope.TextDecoder:null,utf8Decode=str=>{if(!ENCODER)throw new Error("Encoding API not available");return ENCODER.encode(str)},utf8Encode=arr=>{if(!DECODER)throw new Error("Encoding API not available");return DECODER.decode(arr)};class Secret{static fromLatin1(str){return new Secret({buffer:latin1Decode(str).buffer})}static fromUTF8(str){return new Secret({buffer:utf8Decode(str).buffer})}static fromBase32(str){return new Secret({buffer:base32Decode(str).buffer})}static fromHex(str){return new Secret({buffer:hexDecode(str).buffer})}get buffer(){return this.bytes.buffer}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,writable:!1,configurable:!1,value:latin1Encode(this.bytes)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,writable:!1,configurable:!1,value:utf8Encode(this.bytes)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,writable:!1,configurable:!1,value:base32Encode(this.bytes)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,writable:!1,configurable:!1,value:hexEncode(this.bytes)}),this.hex}constructor({buffer,size=20}={}){this.bytes=void 0===buffer?(size=>{if(globalScope.crypto?.getRandomValues)return globalScope.crypto.getRandomValues(new Uint8Array(size));throw new Error("Cryptography API not available")})(size):new Uint8Array(buffer),Object.defineProperty(this,"bytes",{enumerable:!0,writable:!1,configurable:!1,value:this.bytes})}}class HOTP{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}static generate({secret,algorithm=HOTP.defaults.algorithm,digits=HOTP.defaults.digits,counter=HOTP.defaults.counter}){const digest=((algorithm,key,message)=>{if(hmac){const hash=nobleHashes[algorithm]??nobleHashes[canonicalizeAlgorithm(algorithm)];return hmac(hash,key,message)}throw new Error("Missing HMAC function")})(algorithm,secret.bytes,(num=>{const buf=new ArrayBuffer(8),arr=new Uint8Array(buf);let acc=num;for(let i=7;i>=0&&0!==acc;i--)arr[i]=255&acc,acc-=arr[i],acc/=256;return arr})(counter)),offset=15&digest[digest.byteLength-1];return(((127&digest[offset])<<24|(255&digest[offset+1])<<16|(255&digest[offset+2])<<8|255&digest[offset+3])%10**digits).toString().padStart(digits,"0")}generate({counter=this.counter++}={}){return HOTP.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter})}static validate({token,secret,algorithm,digits=HOTP.defaults.digits,counter=HOTP.defaults.counter,window=HOTP.defaults.window}){if(token.length!==digits)return null;let delta=null;const check=i=>{const generatedToken=HOTP.generate({secret,algorithm,digits,counter:i});((a,b)=>{{if(a.length!==b.length)throw new TypeError("Input strings must have the same length");let i=-1,out=0;for(;++i<a.length;)out|=a.charCodeAt(i)^b.charCodeAt(i);return 0===out}})(token,generatedToken)&&(delta=i-counter)};check(counter);for(let i=1;i<=window&&null===delta&&(check(counter-i),null===delta)&&(check(counter+i),null===delta);++i);return delta}validate({token,counter=this.counter,window}){return HOTP.validate({token,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter,window})}toString(){const e=encodeURIComponent;return"otpauth://hotp/"+(this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`)+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`counter=${e(this.counter)}`}constructor({issuer=HOTP.defaults.issuer,label=HOTP.defaults.label,issuerInLabel=HOTP.defaults.issuerInLabel,secret=new Secret,algorithm=HOTP.defaults.algorithm,digits=HOTP.defaults.digits,counter=HOTP.defaults.counter}={}){this.issuer=issuer,this.label=label,this.issuerInLabel=issuerInLabel,this.secret="string"==typeof secret?Secret.fromBase32(secret):secret,this.algorithm=canonicalizeAlgorithm(algorithm),this.digits=digits,this.counter=counter}}class TOTP{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}static counter({period=TOTP.defaults.period,timestamp=Date.now()}={}){return Math.floor(timestamp/1e3/period)}counter({timestamp=Date.now()}={}){return TOTP.counter({period:this.period,timestamp})}static remaining({period=TOTP.defaults.period,timestamp=Date.now()}={}){return 1e3*period-timestamp%(1e3*period)}remaining({timestamp=Date.now()}={}){return TOTP.remaining({period:this.period,timestamp})}static generate({secret,algorithm,digits,period=TOTP.defaults.period,timestamp=Date.now()}){return HOTP.generate({secret,algorithm,digits,counter:TOTP.counter({period,timestamp})})}generate({timestamp=Date.now()}={}){return TOTP.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp})}static validate({token,secret,algorithm,digits,period=TOTP.defaults.period,timestamp=Date.now(),window}){return HOTP.validate({token,secret,algorithm,digits,counter:TOTP.counter({period,timestamp}),window})}validate({token,timestamp,window}){return TOTP.validate({token,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp,window})}toString(){const e=encodeURIComponent;return"otpauth://totp/"+(this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`)+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`period=${e(this.period)}`}constructor({issuer=TOTP.defaults.issuer,label=TOTP.defaults.label,issuerInLabel=TOTP.defaults.issuerInLabel,secret=new Secret,algorithm=TOTP.defaults.algorithm,digits=TOTP.defaults.digits,period=TOTP.defaults.period}={}){this.issuer=issuer,this.label=label,this.issuerInLabel=issuerInLabel,this.secret="string"==typeof secret?Secret.fromBase32(secret):secret,this.algorithm=canonicalizeAlgorithm(algorithm),this.digits=digits,this.period=period}}}}]);