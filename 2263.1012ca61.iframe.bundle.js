/*! For license information please see 2263.1012ca61.iframe.bundle.js.LICENSE.txt */
"use strict";(self.webpackChunkpassbolt_styleguide=self.webpackChunkpassbolt_styleguide||[]).push([[2263],{"./node_modules/otpauth/dist/otpauth.esm.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{__webpack_require__.d(__webpack_exports__,{_k:()=>TOTP});function number(n){if(!Number.isSafeInteger(n)||n<0)throw new Error(`positive integer expected, not ${n}`)}function bytes(b,...lengths){if(!function isBytes(a){return a instanceof Uint8Array||null!=a&&"object"==typeof a&&"Uint8Array"===a.constructor.name}(b))throw new Error("Uint8Array expected");if(lengths.length>0&&!lengths.includes(b.length))throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`)}function exists(instance,checkFinished=!0){if(instance.destroyed)throw new Error("Hash instance has been destroyed");if(checkFinished&&instance.finished)throw new Error("Hash#digest() has already been called")}function output(out,instance){bytes(out);const min=instance.outputLen;if(out.length<min)throw new Error(`digestInto() expects output buffer of length at least ${min}`)}const createView=arr=>new DataView(arr.buffer,arr.byteOffset,arr.byteLength),rotr=(word,shift)=>word<<32-shift|word>>>shift,rotl=(word,shift)=>word<<shift|word>>>32-shift>>>0,isLE=68===new Uint8Array(new Uint32Array([287454020]).buffer)[0];function byteSwap32(arr){for(let i=0;i<arr.length;i++)arr[i]=(word=arr[i])<<24&4278190080|word<<8&16711680|word>>>8&65280|word>>>24&255;var word}function toBytes(data){return"string"==typeof data&&(data=function utf8ToBytes(str){if("string"!=typeof str)throw new Error("utf8ToBytes expected string, got "+typeof str);return new Uint8Array((new TextEncoder).encode(str))}(data)),bytes(data),data}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(hashCons){const hashC=msg=>hashCons().update(toBytes(msg)).digest(),tmp=hashCons();return hashC.outputLen=tmp.outputLen,hashC.blockLen=tmp.blockLen,hashC.create=()=>hashCons(),hashC}class HMAC extends Hash{update(buf){return exists(this),this.iHash.update(buf),this}digestInto(out){exists(this),bytes(out,this.outputLen),this.finished=!0,this.iHash.digestInto(out),this.oHash.update(out),this.oHash.digestInto(out),this.destroy()}digest(){const out=new Uint8Array(this.oHash.outputLen);return this.digestInto(out),out}_cloneInto(to){to||(to=Object.create(Object.getPrototypeOf(this),{}));const{oHash,iHash,finished,destroyed,blockLen,outputLen}=this;return to.finished=finished,to.destroyed=destroyed,to.blockLen=blockLen,to.outputLen=outputLen,to.oHash=oHash._cloneInto(to.oHash),to.iHash=iHash._cloneInto(to.iHash),to}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}constructor(hash$1,_key){super(),this.finished=!1,this.destroyed=!1,function hash(h){if("function"!=typeof h||"function"!=typeof h.create)throw new Error("Hash should be wrapped by utils.wrapConstructor");number(h.outputLen),number(h.blockLen)}(hash$1);const key=toBytes(_key);if(this.iHash=hash$1.create(),"function"!=typeof this.iHash.update)throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const blockLen=this.blockLen,pad=new Uint8Array(blockLen);pad.set(key.length>blockLen?hash$1.create().update(key).digest():key);for(let i=0;i<pad.length;i++)pad[i]^=54;this.iHash.update(pad),this.oHash=hash$1.create();for(let i=0;i<pad.length;i++)pad[i]^=106;this.oHash.update(pad),pad.fill(0)}}const hmac=(hash,key,message)=>new HMAC(hash,key).update(message).digest();hmac.create=(hash,key)=>new HMAC(hash,key);const Chi=(a,b,c)=>a&b^~a&c,Maj=(a,b,c)=>a&b^a&c^b&c;class HashMD extends Hash{update(data){exists(this);const{view,buffer,blockLen}=this,len=(data=toBytes(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);if(take!==blockLen)buffer.set(data.subarray(pos,pos+take),this.pos),this.pos+=take,pos+=take,this.pos===blockLen&&(this.process(view,0),this.pos=0);else{const dataView=createView(data);for(;blockLen<=len-pos;pos+=blockLen)this.process(dataView,pos)}}return this.length+=data.length,this.roundClean(),this}digestInto(out){exists(this),output(out,this),this.finished=!0;const{buffer,view,blockLen,isLE}=this;let{pos}=this;buffer[pos++]=128,this.buffer.subarray(pos).fill(0),this.padOffset>blockLen-pos&&(this.process(view,0),pos=0);for(let i=pos;i<blockLen;i++)buffer[i]=0;!function setBigUint64(view,byteOffset,value,isLE){if("function"==typeof view.setBigUint64)return view.setBigUint64(byteOffset,value,isLE);const _32n=BigInt(32),_u32_max=BigInt(4294967295),wh=Number(value>>_32n&_u32_max),wl=Number(value&_u32_max),h=isLE?4:0,l=isLE?0:4;view.setUint32(byteOffset+h,wh,isLE),view.setUint32(byteOffset+l,wl,isLE)}(view,blockLen-8,BigInt(8*this.length),isLE),this.process(view,0);const oview=createView(out),len=this.outputLen;if(len%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const outLen=len/4,state=this.get();if(outLen>state.length)throw new Error("_sha2: outputLen bigger than state");for(let i=0;i<outLen;i++)oview.setUint32(4*i,state[i],isLE)}digest(){const{buffer,outputLen}=this;this.digestInto(buffer);const res=buffer.slice(0,outputLen);return this.destroy(),res}_cloneInto(to){to||(to=new this.constructor),to.set(...this.get());const{blockLen,buffer,length,finished,destroyed,pos}=this;return to.length=length,to.pos=pos,to.finished=finished,to.destroyed=destroyed,length%blockLen&&to.buffer.set(buffer),to}constructor(blockLen,outputLen,padOffset,isLE){super(),this.blockLen=blockLen,this.outputLen=outputLen,this.padOffset=padOffset,this.isLE=isLE,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(blockLen),this.view=createView(this.buffer)}}const SHA1_IV=new Uint32Array([1732584193,4023233417,2562383102,271733878,3285377520]),SHA1_W=new Uint32Array(80);class SHA1 extends HashMD{get(){const{A,B,C,D,E}=this;return[A,B,C,D,E]}set(A,B,C,D,E){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA1_W[i]=view.getUint32(offset,!1);for(let i=16;i<80;i++)SHA1_W[i]=rotl(SHA1_W[i-3]^SHA1_W[i-8]^SHA1_W[i-14]^SHA1_W[i-16],1);let{A,B,C,D,E}=this;for(let i=0;i<80;i++){let F,K;i<20?(F=Chi(B,C,D),K=1518500249):i<40?(F=B^C^D,K=1859775393):i<60?(F=Maj(B,C,D),K=2400959708):(F=B^C^D,K=3395469782);const T=rotl(A,5)+F+E+K+SHA1_W[i]|0;E=D,D=C,C=rotl(B,30),B=A,A=T}A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,this.set(A,B,C,D,E)}roundClean(){SHA1_W.fill(0)}destroy(){this.set(0,0,0,0,0),this.buffer.fill(0)}constructor(){super(64,20,8,!1),this.A=0|SHA1_IV[0],this.B=0|SHA1_IV[1],this.C=0|SHA1_IV[2],this.D=0|SHA1_IV[3],this.E=0|SHA1_IV[4]}}const sha1=wrapConstructor((()=>new SHA1)),SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends HashMD{get(){const{A,B,C,D,E,F,G,H}=this;return[A,B,C,D,E,F,G,H]}set(A,B,C,D,E,F,G,H){this.A=0|A,this.B=0|B,this.C=0|C,this.D=0|D,this.E=0|E,this.F=0|F,this.G=0|G,this.H=0|H}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA256_W[i]=view.getUint32(offset,!1);for(let i=16;i<64;i++){const W15=SHA256_W[i-15],W2=SHA256_W[i-2],s0=rotr(W15,7)^rotr(W15,18)^W15>>>3,s1=rotr(W2,17)^rotr(W2,19)^W2>>>10;SHA256_W[i]=s1+SHA256_W[i-7]+s0+SHA256_W[i-16]|0}let{A,B,C,D,E,F,G,H}=this;for(let i=0;i<64;i++){const T1=H+(rotr(E,6)^rotr(E,11)^rotr(E,25))+Chi(E,F,G)+SHA256_K[i]+SHA256_W[i]|0,T2=(rotr(A,2)^rotr(A,13)^rotr(A,22))+Maj(A,B,C)|0;H=G,G=F,F=E,E=D+T1|0,D=C,C=B,B=A,A=T1+T2|0}A=A+this.A|0,B=B+this.B|0,C=C+this.C|0,D=D+this.D|0,E=E+this.E|0,F=F+this.F|0,G=G+this.G|0,H=H+this.H|0,this.set(A,B,C,D,E,F,G,H)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}constructor(){super(64,32,8,!1),this.A=0|SHA256_IV[0],this.B=0|SHA256_IV[1],this.C=0|SHA256_IV[2],this.D=0|SHA256_IV[3],this.E=0|SHA256_IV[4],this.F=0|SHA256_IV[5],this.G=0|SHA256_IV[6],this.H=0|SHA256_IV[7]}}class SHA224 extends SHA256{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256=wrapConstructor((()=>new SHA256)),sha224=wrapConstructor((()=>new SHA224)),U32_MASK64=BigInt(2**32-1),_32n=BigInt(32);function fromBig(n,le=!1){return le?{h:Number(n&U32_MASK64),l:Number(n>>_32n&U32_MASK64)}:{h:0|Number(n>>_32n&U32_MASK64),l:0|Number(n&U32_MASK64)}}function split(lst,le=!1){let Ah=new Uint32Array(lst.length),Al=new Uint32Array(lst.length);for(let i=0;i<lst.length;i++){const{h,l}=fromBig(lst[i],le);[Ah[i],Al[i]]=[h,l]}return[Ah,Al]}const rotlSH=(h,l,s)=>h<<s|l>>>32-s,rotlSL=(h,l,s)=>l<<s|h>>>32-s,rotlBH=(h,l,s)=>l<<s-32|h>>>64-s,rotlBL=(h,l,s)=>h<<s-32|l>>>64-s;const u64={fromBig,split,toBig:(h,l)=>BigInt(h>>>0)<<_32n|BigInt(l>>>0),shrSH:(h,_l,s)=>h>>>s,shrSL:(h,l,s)=>h<<32-s|l>>>s,rotrSH:(h,l,s)=>h>>>s|l<<32-s,rotrSL:(h,l,s)=>h<<32-s|l>>>s,rotrBH:(h,l,s)=>h<<64-s|l>>>s-32,rotrBL:(h,l,s)=>h>>>s-32|l<<64-s,rotr32H:(_h,l)=>l,rotr32L:(h,_l)=>h,rotlSH,rotlSL,rotlBH,rotlBL,add:function add(Ah,Al,Bh,Bl){const l=(Al>>>0)+(Bl>>>0);return{h:Ah+Bh+(l/2**32|0)|0,l:0|l}},add3L:(Al,Bl,Cl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0),add3H:(low,Ah,Bh,Ch)=>Ah+Bh+Ch+(low/2**32|0)|0,add4L:(Al,Bl,Cl,Dl)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0),add4H:(low,Ah,Bh,Ch,Dh)=>Ah+Bh+Ch+Dh+(low/2**32|0)|0,add5H:(low,Ah,Bh,Ch,Dh,Eh)=>Ah+Bh+Ch+Dh+Eh+(low/2**32|0)|0,add5L:(Al,Bl,Cl,Dl,El)=>(Al>>>0)+(Bl>>>0)+(Cl>>>0)+(Dl>>>0)+(El>>>0)},[SHA512_Kh,SHA512_Kl]=(()=>u64.split(["0x428a2f98d728ae22","0x7137449123ef65cd","0xb5c0fbcfec4d3b2f","0xe9b5dba58189dbbc","0x3956c25bf348b538","0x59f111f1b605d019","0x923f82a4af194f9b","0xab1c5ed5da6d8118","0xd807aa98a3030242","0x12835b0145706fbe","0x243185be4ee4b28c","0x550c7dc3d5ffb4e2","0x72be5d74f27b896f","0x80deb1fe3b1696b1","0x9bdc06a725c71235","0xc19bf174cf692694","0xe49b69c19ef14ad2","0xefbe4786384f25e3","0x0fc19dc68b8cd5b5","0x240ca1cc77ac9c65","0x2de92c6f592b0275","0x4a7484aa6ea6e483","0x5cb0a9dcbd41fbd4","0x76f988da831153b5","0x983e5152ee66dfab","0xa831c66d2db43210","0xb00327c898fb213f","0xbf597fc7beef0ee4","0xc6e00bf33da88fc2","0xd5a79147930aa725","0x06ca6351e003826f","0x142929670a0e6e70","0x27b70a8546d22ffc","0x2e1b21385c26c926","0x4d2c6dfc5ac42aed","0x53380d139d95b3df","0x650a73548baf63de","0x766a0abb3c77b2a8","0x81c2c92e47edaee6","0x92722c851482353b","0xa2bfe8a14cf10364","0xa81a664bbc423001","0xc24b8b70d0f89791","0xc76c51a30654be30","0xd192e819d6ef5218","0xd69906245565a910","0xf40e35855771202a","0x106aa07032bbd1b8","0x19a4c116b8d2d0c8","0x1e376c085141ab53","0x2748774cdf8eeb99","0x34b0bcb5e19b48a8","0x391c0cb3c5c95a63","0x4ed8aa4ae3418acb","0x5b9cca4f7763e373","0x682e6ff3d6b2b8a3","0x748f82ee5defb2fc","0x78a5636f43172f60","0x84c87814a1f0ab72","0x8cc702081a6439ec","0x90befffa23631e28","0xa4506cebde82bde9","0xbef9a3f7b2c67915","0xc67178f2e372532b","0xca273eceea26619c","0xd186b8c721c0c207","0xeada7dd6cde0eb1e","0xf57d4f7fee6ed178","0x06f067aa72176fba","0x0a637dc5a2c898a6","0x113f9804bef90dae","0x1b710b35131c471b","0x28db77f523047d84","0x32caab7b40c72493","0x3c9ebe0a15c9bebc","0x431d67c49c100d4c","0x4cc5d4becb3e42b6","0x597f299cfc657e2a","0x5fcb6fab3ad6faec","0x6c44198c4a475817"].map((n=>BigInt(n)))))(),SHA512_W_H=new Uint32Array(80),SHA512_W_L=new Uint32Array(80);class SHA512 extends HashMD{get(){const{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;return[Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl]}set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl){this.Ah=0|Ah,this.Al=0|Al,this.Bh=0|Bh,this.Bl=0|Bl,this.Ch=0|Ch,this.Cl=0|Cl,this.Dh=0|Dh,this.Dl=0|Dl,this.Eh=0|Eh,this.El=0|El,this.Fh=0|Fh,this.Fl=0|Fl,this.Gh=0|Gh,this.Gl=0|Gl,this.Hh=0|Hh,this.Hl=0|Hl}process(view,offset){for(let i=0;i<16;i++,offset+=4)SHA512_W_H[i]=view.getUint32(offset),SHA512_W_L[i]=view.getUint32(offset+=4);for(let i=16;i<80;i++){const W15h=0|SHA512_W_H[i-15],W15l=0|SHA512_W_L[i-15],s0h=u64.rotrSH(W15h,W15l,1)^u64.rotrSH(W15h,W15l,8)^u64.shrSH(W15h,W15l,7),s0l=u64.rotrSL(W15h,W15l,1)^u64.rotrSL(W15h,W15l,8)^u64.shrSL(W15h,W15l,7),W2h=0|SHA512_W_H[i-2],W2l=0|SHA512_W_L[i-2],s1h=u64.rotrSH(W2h,W2l,19)^u64.rotrBH(W2h,W2l,61)^u64.shrSH(W2h,W2l,6),s1l=u64.rotrSL(W2h,W2l,19)^u64.rotrBL(W2h,W2l,61)^u64.shrSL(W2h,W2l,6),SUMl=u64.add4L(s0l,s1l,SHA512_W_L[i-7],SHA512_W_L[i-16]),SUMh=u64.add4H(SUMl,s0h,s1h,SHA512_W_H[i-7],SHA512_W_H[i-16]);SHA512_W_H[i]=0|SUMh,SHA512_W_L[i]=0|SUMl}let{Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl}=this;for(let i=0;i<80;i++){const sigma1h=u64.rotrSH(Eh,El,14)^u64.rotrSH(Eh,El,18)^u64.rotrBH(Eh,El,41),sigma1l=u64.rotrSL(Eh,El,14)^u64.rotrSL(Eh,El,18)^u64.rotrBL(Eh,El,41),CHIh=Eh&Fh^~Eh&Gh,CHIl=El&Fl^~El&Gl,T1ll=u64.add5L(Hl,sigma1l,CHIl,SHA512_Kl[i],SHA512_W_L[i]),T1h=u64.add5H(T1ll,Hh,sigma1h,CHIh,SHA512_Kh[i],SHA512_W_H[i]),T1l=0|T1ll,sigma0h=u64.rotrSH(Ah,Al,28)^u64.rotrBH(Ah,Al,34)^u64.rotrBH(Ah,Al,39),sigma0l=u64.rotrSL(Ah,Al,28)^u64.rotrBL(Ah,Al,34)^u64.rotrBL(Ah,Al,39),MAJh=Ah&Bh^Ah&Ch^Bh&Ch,MAJl=Al&Bl^Al&Cl^Bl&Cl;Hh=0|Gh,Hl=0|Gl,Gh=0|Fh,Gl=0|Fl,Fh=0|Eh,Fl=0|El,({h:Eh,l:El}=u64.add(0|Dh,0|Dl,0|T1h,0|T1l)),Dh=0|Ch,Dl=0|Cl,Ch=0|Bh,Cl=0|Bl,Bh=0|Ah,Bl=0|Al;const All=u64.add3L(T1l,sigma0l,MAJl);Ah=u64.add3H(All,T1h,sigma0h,MAJh),Al=0|All}({h:Ah,l:Al}=u64.add(0|this.Ah,0|this.Al,0|Ah,0|Al)),({h:Bh,l:Bl}=u64.add(0|this.Bh,0|this.Bl,0|Bh,0|Bl)),({h:Ch,l:Cl}=u64.add(0|this.Ch,0|this.Cl,0|Ch,0|Cl)),({h:Dh,l:Dl}=u64.add(0|this.Dh,0|this.Dl,0|Dh,0|Dl)),({h:Eh,l:El}=u64.add(0|this.Eh,0|this.El,0|Eh,0|El)),({h:Fh,l:Fl}=u64.add(0|this.Fh,0|this.Fl,0|Fh,0|Fl)),({h:Gh,l:Gl}=u64.add(0|this.Gh,0|this.Gl,0|Gh,0|Gl)),({h:Hh,l:Hl}=u64.add(0|this.Hh,0|this.Hl,0|Hh,0|Hl)),this.set(Ah,Al,Bh,Bl,Ch,Cl,Dh,Dl,Eh,El,Fh,Fl,Gh,Gl,Hh,Hl)}roundClean(){SHA512_W_H.fill(0),SHA512_W_L.fill(0)}destroy(){this.buffer.fill(0),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}constructor(){super(128,64,16,!1),this.Ah=1779033703,this.Al=-205731576,this.Bh=-1150833019,this.Bl=-2067093701,this.Ch=1013904242,this.Cl=-23791573,this.Dh=-1521486534,this.Dl=1595750129,this.Eh=1359893119,this.El=-1377402159,this.Fh=-1694144372,this.Fl=725511199,this.Gh=528734635,this.Gl=-79577749,this.Hh=1541459225,this.Hl=327033209}}class SHA384 extends SHA512{constructor(){super(),this.Ah=-876896931,this.Al=-1056596264,this.Bh=1654270250,this.Bl=914150663,this.Ch=-1856437926,this.Cl=812702999,this.Dh=355462360,this.Dl=-150054599,this.Eh=1731405415,this.El=-4191439,this.Fh=-1900787065,this.Fl=1750603025,this.Gh=-619958771,this.Gl=1694076839,this.Hh=1203062813,this.Hl=-1090891868,this.outputLen=48}}const sha512=wrapConstructor((()=>new SHA512)),sha384=wrapConstructor((()=>new SHA384)),SHA3_PI=[],SHA3_ROTL=[],_SHA3_IOTA=[],_0n=BigInt(0),_1n=BigInt(1),_2n=BigInt(2),_7n=BigInt(7),_256n=BigInt(256),_0x71n=BigInt(113);for(let round=0,R=_1n,x=1,y=0;round<24;round++){[x,y]=[y,(2*x+3*y)%5],SHA3_PI.push(2*(5*y+x)),SHA3_ROTL.push((round+1)*(round+2)/2%64);let t=_0n;for(let j=0;j<7;j++)R=(R<<_1n^(R>>_7n)*_0x71n)%_256n,R&_2n&&(t^=_1n<<(_1n<<BigInt(j))-_1n);_SHA3_IOTA.push(t)}const[SHA3_IOTA_H,SHA3_IOTA_L]=split(_SHA3_IOTA,!0),rotlH=(h,l,s)=>s>32?rotlBH(h,l,s):rotlSH(h,l,s),rotlL=(h,l,s)=>s>32?rotlBL(h,l,s):rotlSL(h,l,s);class Keccak extends Hash{keccak(){isLE||byteSwap32(this.state32),function keccakP(s,rounds=24){const B=new Uint32Array(10);for(let round=24-rounds;round<24;round++){for(let x=0;x<10;x++)B[x]=s[x]^s[x+10]^s[x+20]^s[x+30]^s[x+40];for(let x=0;x<10;x+=2){const idx1=(x+8)%10,idx0=(x+2)%10,B0=B[idx0],B1=B[idx0+1],Th=rotlH(B0,B1,1)^B[idx1],Tl=rotlL(B0,B1,1)^B[idx1+1];for(let y=0;y<50;y+=10)s[x+y]^=Th,s[x+y+1]^=Tl}let curH=s[2],curL=s[3];for(let t=0;t<24;t++){const shift=SHA3_ROTL[t],Th=rotlH(curH,curL,shift),Tl=rotlL(curH,curL,shift),PI=SHA3_PI[t];curH=s[PI],curL=s[PI+1],s[PI]=Th,s[PI+1]=Tl}for(let y=0;y<50;y+=10){for(let x=0;x<10;x++)B[x]=s[y+x];for(let x=0;x<10;x++)s[y+x]^=~B[(x+2)%10]&B[(x+4)%10]}s[0]^=SHA3_IOTA_H[round],s[1]^=SHA3_IOTA_L[round]}B.fill(0)}(this.state32,this.rounds),isLE||byteSwap32(this.state32),this.posOut=0,this.pos=0}update(data){exists(this);const{blockLen,state}=this,len=(data=toBytes(data)).length;for(let pos=0;pos<len;){const take=Math.min(blockLen-this.pos,len-pos);for(let i=0;i<take;i++)state[this.pos++]^=data[pos++];this.pos===blockLen&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;const{state,suffix,pos,blockLen}=this;state[pos]^=suffix,128&suffix&&pos===blockLen-1&&this.keccak(),state[blockLen-1]^=128,this.keccak()}writeInto(out){exists(this,!1),bytes(out),this.finish();const bufferOut=this.state,{blockLen}=this;for(let pos=0,len=out.length;pos<len;){this.posOut>=blockLen&&this.keccak();const take=Math.min(blockLen-this.posOut,len-pos);out.set(bufferOut.subarray(this.posOut,this.posOut+take),pos),this.posOut+=take,pos+=take}return out}xofInto(out){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(out)}xof(bytes){return number(bytes),this.xofInto(new Uint8Array(bytes))}digestInto(out){if(output(out,this),this.finished)throw new Error("digest() was already called");return this.writeInto(out),this.destroy(),out}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,this.state.fill(0)}_cloneInto(to){const{blockLen,suffix,outputLen,rounds,enableXOF}=this;return to||(to=new Keccak(blockLen,suffix,outputLen,enableXOF,rounds)),to.state32.set(this.state32),to.pos=this.pos,to.posOut=this.posOut,to.finished=this.finished,to.rounds=rounds,to.suffix=suffix,to.outputLen=outputLen,to.enableXOF=enableXOF,to.destroyed=this.destroyed,to}constructor(blockLen,suffix,outputLen,enableXOF=!1,rounds=24){if(super(),this.blockLen=blockLen,this.suffix=suffix,this.outputLen=outputLen,this.enableXOF=enableXOF,this.rounds=rounds,this.pos=0,this.posOut=0,this.finished=!1,this.destroyed=!1,number(outputLen),0>=this.blockLen||this.blockLen>=200)throw new Error("Sha3 supports only keccak-f1600 function");var arr;this.state=new Uint8Array(200),this.state32=(arr=this.state,new Uint32Array(arr.buffer,arr.byteOffset,Math.floor(arr.byteLength/4)))}}const gen=(suffix,blockLen,outputLen)=>wrapConstructor((()=>new Keccak(blockLen,suffix,outputLen))),sha3_224=gen(6,144,28),sha3_256=gen(6,136,32),sha3_384=gen(6,104,48),sha3_512=gen(6,72,64),globalScope=(()=>{if("object"==typeof globalThis)return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if("undefined"!=typeof __GLOBALTHIS__)return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}return"undefined"!=typeof self?self:"undefined"!=typeof window?window:void 0!==__webpack_require__.g?__webpack_require__.g:void 0})(),OPENSSL_NOBLE_HASHES={SHA1:sha1,SHA224:sha224,SHA256:sha256,SHA384:sha384,SHA512:sha512,"SHA3-224":sha3_224,"SHA3-256":sha3_256,"SHA3-384":sha3_384,"SHA3-512":sha3_512},ALPHABET="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",base32Decode=str=>{let end=str.length;for(;"="===str[end-1];)--end;const cstr=(end<str.length?str.substring(0,end):str).toUpperCase(),buf=new ArrayBuffer(5*cstr.length/8|0),arr=new Uint8Array(buf);let bits=0,value=0,index=0;for(let i=0;i<cstr.length;i++){const idx=ALPHABET.indexOf(cstr[i]);if(-1===idx)throw new TypeError(`Invalid character found: ${cstr[i]}`);value=value<<5|idx,bits+=5,bits>=8&&(bits-=8,arr[index++]=value>>>bits)}return arr},base32Encode=arr=>{let bits=0,value=0,str="";for(let i=0;i<arr.length;i++)for(value=value<<8|arr[i],bits+=8;bits>=5;)str+=ALPHABET[value>>>bits-5&31],bits-=5;return bits>0&&(str+=ALPHABET[value<<5-bits&31]),str},hexDecode=str=>{const buf=new ArrayBuffer(str.length/2),arr=new Uint8Array(buf);for(let i=0;i<str.length;i+=2)arr[i/2]=parseInt(str.substring(i,i+2),16);return arr},hexEncode=arr=>{let str="";for(let i=0;i<arr.length;i++){const hex=arr[i].toString(16);1===hex.length&&(str+="0"),str+=hex}return str.toUpperCase()},latin1Decode=str=>{const buf=new ArrayBuffer(str.length),arr=new Uint8Array(buf);for(let i=0;i<str.length;i++)arr[i]=255&str.charCodeAt(i);return arr},latin1Encode=arr=>{let str="";for(let i=0;i<arr.length;i++)str+=String.fromCharCode(arr[i]);return str},ENCODER=globalScope.TextEncoder?new globalScope.TextEncoder:null,DECODER=globalScope.TextDecoder?new globalScope.TextDecoder:null,utf8Decode=str=>{if(!ENCODER)throw new Error("Encoding API not available");return ENCODER.encode(str)},utf8Encode=arr=>{if(!DECODER)throw new Error("Encoding API not available");return DECODER.decode(arr)};class Secret{static fromLatin1(str){return new Secret({buffer:latin1Decode(str).buffer})}static fromUTF8(str){return new Secret({buffer:utf8Decode(str).buffer})}static fromBase32(str){return new Secret({buffer:base32Decode(str).buffer})}static fromHex(str){return new Secret({buffer:hexDecode(str).buffer})}get buffer(){return this.bytes.buffer}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,writable:!1,configurable:!1,value:latin1Encode(this.bytes)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,writable:!1,configurable:!1,value:utf8Encode(this.bytes)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,writable:!1,configurable:!1,value:base32Encode(this.bytes)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,writable:!1,configurable:!1,value:hexEncode(this.bytes)}),this.hex}constructor({buffer,size=20}={}){this.bytes=void 0===buffer?(size=>{if(globalScope.crypto?.getRandomValues)return globalScope.crypto.getRandomValues(new Uint8Array(size));throw new Error("Cryptography API not available")})(size):new Uint8Array(buffer),Object.defineProperty(this,"bytes",{enumerable:!0,writable:!1,configurable:!1,value:this.bytes})}}class HOTP{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}static generate({secret,algorithm=HOTP.defaults.algorithm,digits=HOTP.defaults.digits,counter=HOTP.defaults.counter}){const digest=((algorithm,key,message)=>{if(hmac){const hash=OPENSSL_NOBLE_HASHES[algorithm.toUpperCase()];if(!hash)throw new TypeError("Unknown hash function");return hmac(hash,key,message)}throw new Error("Missing HMAC function")})(algorithm,secret.bytes,(num=>{const buf=new ArrayBuffer(8),arr=new Uint8Array(buf);let acc=num;for(let i=7;i>=0&&0!==acc;i--)arr[i]=255&acc,acc-=arr[i],acc/=256;return arr})(counter)),offset=15&digest[digest.byteLength-1];return(((127&digest[offset])<<24|(255&digest[offset+1])<<16|(255&digest[offset+2])<<8|255&digest[offset+3])%10**digits).toString().padStart(digits,"0")}generate({counter=this.counter++}={}){return HOTP.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter})}static validate({token,secret,algorithm,digits,counter=HOTP.defaults.counter,window=HOTP.defaults.window}){if(token.length!==digits)return null;let delta=null;const check=i=>{const generatedToken=HOTP.generate({secret,algorithm,digits,counter:i});((a,b)=>{{if(a.length!==b.length)throw new TypeError("Input strings must have the same length");let i=-1,out=0;for(;++i<a.length;)out|=a.charCodeAt(i)^b.charCodeAt(i);return 0===out}})(token,generatedToken)&&(delta=i-counter)};check(counter);for(let i=1;i<=window&&null===delta&&(check(counter-i),null===delta)&&(check(counter+i),null===delta);++i);return delta}validate({token,counter=this.counter,window}){return HOTP.validate({token,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter,window})}toString(){const e=encodeURIComponent;return"otpauth://hotp/"+(this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`)+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`counter=${e(this.counter)}`}constructor({issuer=HOTP.defaults.issuer,label=HOTP.defaults.label,issuerInLabel=HOTP.defaults.issuerInLabel,secret=new Secret,algorithm=HOTP.defaults.algorithm,digits=HOTP.defaults.digits,counter=HOTP.defaults.counter}={}){this.issuer=issuer,this.label=label,this.issuerInLabel=issuerInLabel,this.secret="string"==typeof secret?Secret.fromBase32(secret):secret,this.algorithm=algorithm.toUpperCase(),this.digits=digits,this.counter=counter}}class TOTP{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}static generate({secret,algorithm,digits,period=TOTP.defaults.period,timestamp=Date.now()}){return HOTP.generate({secret,algorithm,digits,counter:Math.floor(timestamp/1e3/period)})}generate({timestamp=Date.now()}={}){return TOTP.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp})}static validate({token,secret,algorithm,digits,period=TOTP.defaults.period,timestamp=Date.now(),window}){return HOTP.validate({token,secret,algorithm,digits,counter:Math.floor(timestamp/1e3/period),window})}validate({token,timestamp,window}){return TOTP.validate({token,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp,window})}toString(){const e=encodeURIComponent;return"otpauth://totp/"+(this.issuer.length>0?this.issuerInLabel?`${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?issuer=${e(this.issuer)}&`:`${e(this.label)}?`)+`secret=${e(this.secret.base32)}&`+`algorithm=${e(this.algorithm)}&`+`digits=${e(this.digits)}&`+`period=${e(this.period)}`}constructor({issuer=TOTP.defaults.issuer,label=TOTP.defaults.label,issuerInLabel=TOTP.defaults.issuerInLabel,secret=new Secret,algorithm=TOTP.defaults.algorithm,digits=TOTP.defaults.digits,period=TOTP.defaults.period}={}){this.issuer=issuer,this.label=label,this.issuerInLabel=issuerInLabel,this.secret="string"==typeof secret?Secret.fromBase32(secret):secret,this.algorithm=algorithm.toUpperCase(),this.digits=digits,this.period=period}}}}]);